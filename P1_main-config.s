; Archivo: main_lab04.s
; Dispositivo: PIC16F887
; Autor: Luis Genaro Alvarez Sulecio
; Compilador: pic-as (v2.30), MPLABX V5.40
;
; Programa: PROYECTO 1 RELOJ DIGITAL
; Hardware: 7 SEGMENT DISPLAY, PUSHBUTTONS Y LEDS
;
; Creado: 17 mar, 2022
; Última modificación: 25 mar, 2022

; PIC16F887 Configuration Bit Settings

; Assembly source line config statements

PROCESSOR 16F887  

//---------------------------CONFIGURACION WORD1--------------------------------
  CONFIG  FOSC = INTRC_NOCLKOUT ; Oscillator Selection bits (INTOSCIO oscillator: I/O function on RA6/OSC2/CLKOUT pin, I/O function on RA7/OSC1/CLKIN)
  CONFIG  WDTE = OFF            ; Watchdog Timer Enable bit (WDT disabled and can be enabled by SWDTEN bit of the WDTCON register)
  CONFIG  PWRTE = OFF            ; Power-up Timer Enable bit (PWRT enabled)
  CONFIG  MCLRE = OFF           ; RE3/MCLR pin function select bit (RE3/MCLR pin function is digital input, MCLR internally tied to VDD)
  CONFIG  CP = OFF              ; Code Protection bit (Program memory code protection is disabled)
  CONFIG  CPD = OFF             ; Data Code Protection bit (Data memory code protection is disabled)
  CONFIG  BOREN = OFF           ; Brown Out Reset Selection bits (BOR disabled)
  CONFIG  IESO = OFF            ; Internal External Switchover bit (Internal/External Switchover mode is disabled)
  CONFIG  FCMEN = OFF           ; Fail-Safe Clock Monitor Enabled bit (Fail-Safe Clock Monitor is disabled)
  CONFIG  LVP = OFF              ; Low Voltage Programming Enable bit (RB3/PGM pin has PGM function, low voltage programming enabled)

//---------------------------CONFIGURACION WORD2--------------------------------
  CONFIG  BOR4V = BOR40V        ; Brown-out Reset Selection bit (Brown-out Reset set to 4.0V)
  CONFIG  WRT = OFF             ; Flash Program Memory Self Write Enable bits (Write protection off)

// config statements should precede project file includes.
#include <xc.inc>
  
//---------------------------------MACROS---------------------------------------
//+++++++++++++++++++++++MACRO PARA RESETEO DEL TIMER 0+++++++++++++++++++++++++
RESET_TMR0 MACRO TMR_VAR
    BANKSEL TMR0		; SELECCIONAR EL BANK 2 DEL TMR0
    MOVLW   TMR_VAR		; CARGAR EL VALOR RECIBIDO POR LA FUNCIÓN AL REGISTRO W
    MOVWF   TMR0		; CARGAR EL VALOR DEL REGISTRO W AL TMR0
    BCF	    T0IF		; LIMPIAR BANDERA DEL TIMER0
    ENDM

//+++++++++++++++++++++++MACRO PARA RESETEO DEL TIMER 1+++++++++++++++++++++++++  
    ; TOMA LOS VALORES DADOS PARA TMR1H Y TMR1L
TMR1_RESET MACRO TMR1_H, TMR1_L	; MACRO PARA RESETEO DEL TMR1
    MOVLW   TMR1_H		; PREPARACION DEL VALRO A CARGAR EN TMR1H
    MOVWF   TMR1H		; GARGA DEL VALOR AL TMR1H
    MOVLW   TMR1_L		; PREPARACION DEL VALOR A CARGAR EN TMR1L
    MOVWF   TMR1L		; CARGA DEL VALOR AL TMR1L
    BCF	    TMR1IF		; LIMPIADO DE LA BANDERA DE INTERRUPCIONES PARA EL TMR1
    ENDM    
  
//++++++++++++++++++MACRO PARA CARGAR VALORES A LOS DISPLAYS++++++++++++++++++++
    ; RECIVE CUATRO VARIABLES DE 1 DIGITO CADA UNA PARA MOSTRAR
    ; EL VALOR CORRESPONDIENTE SEGUN LA POSICION DEL VALOR (UNIDADES O DECENAS)
SET_DISPLAY MACRO DISP1, DISP2, DISP3, DISP4
    MOVF    DISP1, W		; MOVER VALOR DE CUENTA EN SEGUDOS AL REGISTRO W
    CALL    HEX_INDEX		; INICIAR SUBRUTINA DE TABLA HEXADECIMAL
    MOVWF   R_display		; CARGAR VALOR EN HEXADECIMAL A VARIABLE DE DISPLAY_0
    
    MOVF    DISP2, W		; MOVER VALOR DE CUENTA EN DECENAS DE SEGUNDOS AL REGISTRO W
    CALL    HEX_INDEX		; INICIAR SUBRUTINA DE TABLA HEXADECIMAL
    MOVWF   R_display+1		; CARGAR VALOR EN HEXADECIMAL A VARIABLE DE DISPLAY_1
    
    MOVF    DISP3, W
    CALL    HEX_INDEX
    MOVWF   L_display
    
    MOVF    DISP4, W
    CALL    HEX_INDEX
    MOVWF   L_display+1
    ENDM    
    
//++++++++++++++++++++++MACRO PARA REVISION DE UNDERFLOW++++++++++++++++++++++++
    ; COMPARA EL VALOR DE UNA VARIABLE DADA CON UN VALOR ESPECIFICADO (RESULTADO DE UNDERFLOW)
    ; Y REEMPLAZAR EL VALOR DE LA VARIABLE CON UN NUEVO VALOR SI EXISTE UNA IGUALDAD
    ; "UF_VAL" RECIVE EL VALOR DE UNDERFLOW
    ; "TRUE_VAL" RECIVE EL VALOR QUE DEBERIA TOMAR LA CUENTA SI HAY UNDERFLOW
    ; "DEC_VAR_1" TOMA LA VARIABLE QUE SE DESEA REVISAR
    ; "POS_B" RECIVE UNA POSICION A LA QUE SE DESEA IR EN CASO DE QUE NO HAYA UNDERFLOW
DEC_UF_TEST MACRO UF_VAL, TRUE_VAL, DEC_VAR_1, POS_B
    MOVF    DEC_VAR_1, W
    SUBLW   UF_VAL
    BTFSS   ZERO
    GOTO    POS_B
    MOVLW   TRUE_VAL
    MOVWF   DEC_VAR_1
    ENDM
    
//+++++++++++++++++++++++MACRO PARA REVISION DE OVERFLOW++++++++++++++++++++++++
    ; COMPARA EL VALOR DE UNA VARIABLE DADA CON UN VALOR ESPECIFICADO (RESULTADO DE OVERFLOW)
    ; Y LIMPIAR EL VALOR DE LA VARIABLE SI EXISTE UNA IGUALDAD
    ; "OF_VAL" RECIVE EL VALOR DE OVERFLOW
    ; "INC_VAR_1" TOMA LA VARIABLE QUE SE DESEA REVISAR
    ; "POS_A" RECIVE UNA POSICION A LA QUE SE DESEA IR EN CASO DE QUE NO HAYA OVERFLOW
INC_OF_TEST MACRO OF_VAL, INC_VAR_1, POS_A
    MOVF    INC_VAR_1, W
    SUBLW   OF_VAL
    BTFSS   ZERO
    GOTO    POS_A
    CLRF    INC_VAR_1
    ENDM
    
//+++++++++++++++++MACRO PARA REVISION DE VARIABLES SUCESIVAS+++++++++++++++++++
    ; RESIVE 4 VARIABLES CUYO VALOR SE DESEA REVISAR PARA DETERMINAR SI HAN LLEGADO A 0
    ; O SI ESTAS TIENE EL VALOR DE 0. ADICIONALMENTE, RESIVEN 2 POSICIONES A LAS CUALES
    ; SE DESEA IR EN FUNCION DE SI UNA O MAS VARIABLES SON 0 O NO
CONT_TEST   MACRO CONT1, CONT2, CONT3, CONT4, POS1, POS2
    MOVF    CONT1, W
    SUBLW   0
    BTFSS   ZERO
    GOTO    POS1
    MOVF    CONT2, W
    SUBLW   0
    BTFSS   ZERO
    GOTO    POS1
    MOVF    CONT3, W
    SUBLW   0
    BTFSS   ZERO
    GOTO    POS1
    MOVF    CONT4, W
    SUBLW   0
    BTFSS   ZERO
    GOTO    POS1
    GOTO    POS2
    ENDM
  
//----------------------------VARIABLES EN MEMORIA------------------------------
PSECT udata_bank0
    alarma:		DS 1	; BANDERA PARA ALARMA
    cont_alarma:	DS 1	; CUENTA PARA APAGADOAUTOMATICO DE LA ALARMA
    edicion:		DS 1	; BANDERA PARA EDICION DE ESTADOS
    estado:		DS 1	; BANDERA PARA IDENTIFICACION DE ESTADOS
    inc_flag:		DS 1	; BANDERA PARA INCREMENTOS
    Cont_Hora:		DS 1	; VARIABLE DE CONTEO PARA 1 SEGUNDO DE FUNCIÓN HORA
    cont_useg:		DS 1	; VARIABLE DE CUENTA DE UNIDADES DE SEGUNDOS PARA RELOJ
    cont_dseg:		DS 1	; VARIABLE DE CUENTA DE DECENAS DE SEGUNDOS PARA RELOJ
    cont_umin:		DS 1	; VARIABLE DE CUENTA DE UNIDADES DE MINUTOS PARA RELOJ
    cont_dmin:		DS 1	; VARIABLE DE CUENTA DE DECENAS DE MINUTOS PARA RELOJ
    cont_uhor:		DS 1	; VARIABLE DE CUENTA DE UNIDADES DE HORA PARA RELOJ
    cont_dhor:		DS 1	; VARIABLE DE CUENTA DE DECENAS DE HORA PARA RELOJ
    tmr_var:		DS 1	; BANDERA PARA DETERMINAR SI SE ESTA DECREMENTANDO LA CUENTA DEL TIMER
    tmr_cont:		DS 1	; VARIABLE DE CUENTA DEL TIMER PARA LLEGAR A 1 SEGUNDO
    tmr_useg:		DS 1	; VARIABLE DE CUENTA DE UNIDADES DE SEGUNDO PARA TIMER
    tmr_dseg:		DS 1	; VARIABLE DE CUENTA DE DECENAS DE SEGUNDO PARA TIMER
    tmr_umin:		DS 1	; VARIABLE DE CUENTA DE UNIDADES DE MINUTO PARA TIMER
    tmr_dmin:		DS 1	; VARIABLE DE CUENTA DE DECENAS DE MINUTO PARA TIMER
    Cont_T2:		DS 1	; VARIABLE DE CONTEO PARA TMR2
    bandera:		DS 1	; BANDERA PARA MULTIPLEXADO
    edit:		DS 1	; BANDERA DE SELECCION DE CUENTA A EDITAR (MINUTOS/HORAS O SEGUNDOS/MINUTOS)
    the_end:		DS 1	; BANDERA DE OVERFLOW PARA 24 HORAS
    L_display:		DS 2	; VARIABLE PARA DISPLAY IZQUIERDO
    R_display:		DS 2	; VARIABLE PARA DISPLAY DERECHO
  
//-----------------------VARIABLES EN MEMORIA COMPARTIDA------------------------
PSECT udata_shr			; VARIABLES COMPARTIDAS
    W_TEMP:		DS 1	; VARIABLE TEMPORAL PARA REGISTRO W
    STATUS_TEMP:	DS 1	; VARIABLE REMPORAL PARA STATUS  
  
//-----------------------------VECTOR DE REINICIO-------------------------------
 PSECT resVect, class = CODE, abs, delta = 2;
 ORG 00h			; Posición 0000h RESET
 resetVec:			; Etiqueta para el vector de reset
    PAGESEL main
    goto main
  
 PSECT intVect, class = CODE, abs, delta = 2, abs
 ORG 04h			; Posición de la interrupción
 
//--------------------------VECTOR DE INTERRUPCIONES----------------------------
PUSH:
    MOVWF   W_TEMP		; COLOCAR FALOR DEL REGISTRO W EN VARIABLE TEMPORAL
    SWAPF   STATUS, W		; INTERCAMBIAR STATUS CON REGISTRO W
    MOVWF   STATUS_TEMP		; CARGAR VALOR REGISTRO W A VARAIBLE TEMPORAL
    
ISR: 
    BTFSC   RBIF		; INT PORTB, SI=1 NO=0
    CALL    INT_IOCRB		; SI -> CORRER SUBRUTINA DE INTERRUPCIÓN
    
    BTFSC   T0IF		; INT TMR0, SI=1 NO=0
    CALL    TMR0_INT		; SI -> CORRER SUBRUTINA DE INTERRUPCIÓN
    
    BTFSC   edicion, 0
    GOTO    $+3
    BTFSC   TMR1IF		; REVISION DEL ESTADO DE LA BANDERA DE INTERRUPCION DEL TMR1
    CALL    TMR1_INT		; INICIAR INTERRUPCION DEL TMR1
    
    BTFSC   TMR2IF		; REVISION DEL ESTADO DE LA BANDERA DE INTERRUPCION DEL TMR2
    CALL    TMR2_INT		; INICIAR INTERRUPCION DEL TMR2
    
POP:
    SWAPF   STATUS_TEMP, W	; INTERCAMBIAR VALOR DE VARIABLE TEMPORAL DE ESTATUS CON W
    MOVWF   STATUS		; CARGAR REGISTRO W A STATUS
    SWAPF   W_TEMP, F		; INTERCAMBIAR VARIABLE TEMPORAL DE REGISTRO W CON REGISTRO F
    SWAPF   W_TEMP, W		; INTERCAMBIAR VARIABLE TEMPORAL DE REGISTRO W CON REGISTRO W
    RETFIE   
    
//----------------------------INT SUBRUTINAS------------------------------------    
//++++++++++++++++++++++++INTERRUPCION PUSHBUTTONS++++++++++++++++++++++++++++++
INT_IOCRB:			; SUBRUTINA DE INTERRUPCION EN PORTB
    BANKSEL PORTA		; SELECCIONAR BANCO 0
    BTFSS   PORTB, 0		; REVISAR SI EL BIT DEL PRIMER BOTON EN RB HA CAMBIADO A 0
    CALL    FMS_CONFIG		; SI HA CAMBIADO A 0 (HA SIDO PRESIONADO) IR A CONFIGURACION DE ESTADOS
    BTFSS   PORTB, 1		; REVISAR SI EL BIT DEL SEGUNDO BOTON EN RB HA CAMBIADO A 0
    CALL    INC_CONFIG		; SI HA CAMBIADO A 0 (HA SIDO PRESIONADO) IR A CONFIGURACION DE INCREMENTACION
    BTFSS   PORTB, 2		; REVISAR SI EL BIT DEL SEGUNDO BOTON EN RB HA CAMBIADO A 0
    CALL    DEC_CONFIG		; SI HA CAMBIADO A 0 (HA SIDO PRESIONADO) IR A CONFIGURACION DE DECREMENTACION
    BTFSS   PORTB, 3		; REVISAR SI EL BIT DEL SEGUNDO BOTON EN RB HA CAMBIADO A 0
    CALL    EDIT_CONFIG		; SI HA CAMBIADO A 0 (HA SIDO PRESIONADO) IR A CONFIGURACION DE EDICION
    BCF	    RBIF		; LIMPIAR LA BANDERA DE PORTB
    RETURN     
 
//++++++++++++++++++++++++++INTERRUPCION TIMER 0++++++++++++++++++++++++++++++++
TMR0_INT:			; SUBRUTINA DE INTERRUPCION DEL TIMER 0
    RESET_TMR0 250		; REINICIAR TMR0 CADA 2mS
    CLRF    PORTD		; LIMPIEZA DEL PUERTO D
    CALL    SHOW_DISPLAY	; LLAMAR SUBRUTINA PARA MOSTRAR EL DISPLAY
    RETURN

//++++++++++++++++++++++++++INTERRUPCION TIMER 1++++++++++++++++++++++++++++++++
TMR1_INT:			; SUBRUTINA DE INTERRUPCION DEL TIMER 1
    TMR1_RESET	0x0B, 0xDC	; REINICIO DEL TMR1
    INCF    Cont_Hora		; INCREMENTO EN CUENTA
    MOVF    Cont_Hora, W	; CARGA DE CUENTA A REGISTRO W
    SUBLW   2			; USO DE RESTA PARA DETERMINAR SI LA CUENTA HA LLEGADO A 2X500mS QUE SERIA 1S
    BTFSC   ZERO		; SI NO SE HA LLEGADO AL SEGUNDO SALIR DE LA INTERRUPCION
    GOTO    INC_USEG		; SI SE LLEGO AL SEGUNDO IR A SUBRUTINA DE INCREMENTO DE SEGUNDOS
    RETURN    
 
INC_USEG:			; INCREMENTO DE UNIDADES DE SEGUNDOS CON TMR1
    BTFSS   alarma, 0		; REVISION SI LA ALARMA ESTA ACTIVADA
    GOTO    NEXT		; SI NO ESTA ACTIVADA CONTINUAR LA SUBRUTINA NORMAL
    CALL    DEC_ALARM		; SI ESTA ACTIVADA LLAMAR SUBRUTINA DE CUENTA REGRESIVA PARA APAGADO DE ALARMA
    NEXT:
    CLRF    Cont_Hora		; LIMPIAR CUENTA DE TMR1
    INCF    cont_useg		; INCREMENTO DE CUENTA DE UNIDADES DE SEGUNDO
    MOVF    cont_useg, W	; CARGAR CUENTA PARA REVISION DE OVERFLOW
    SUBLW   10			; VALOR DE OVERFLOW
    BTFSC   ZERO		; REVISION DE OVERFLOW
    GOTO    INC_DSEG		; SI HUBO OVERFLOW INCREMENTAR DECENAS DE SEGUNDOS
    RETURN
 
INC_DSEG:			; INCREMENTO DE DECENAS DE SEGUNDOS CON TMR1
    CLRF    cont_useg		; LIMPIAR CUENTA DE UNIDADES DE SEGUNDO
    INCF    cont_dseg		; INCREMENTO DE CUENTA DE DECENAS DE SEGUNDO
    MOVF    cont_dseg, W	; CARGAR CUENTA PARA REVISION DE OVERFLOW
    SUBLW   6			; VALOR DE OVERFLOW
    BTFSC   ZERO		; REVISION DE OVERFLOW
    GOTO    INC_UMIN		; SI HUBO OVERFLOW INCREMENTAR UNIDADES DE MINUTOS
    RETURN
    
INC_UMIN:			; INCREMENTO DE UNIDADES DE MINUTOS CON TMR1
    CLRF    cont_dseg		; LIMPIAR CUENTA DE DECENAS DE SEGUNDO
    INCF    cont_umin		; INCREMENTO DE CUENTA DE UNIDADES DE MINUTO
    MOVF    cont_umin, W	; CARGAR CUENTA PARA REVISION DE OVERFLOW
    SUBLW   10			; VALOR DE OVERFLOW
    BTFSC   ZERO		; REVISION DE OVERFLOW
    GOTO    INC_DMIN		; SI HUBO OVERFLOW INCREMENTAR DECENAS DE MINUTOS
    RETURN
    
INC_DMIN:			; INCREMENTO DE DECENAS DE MINUTOS CON TMR1
    CLRF    cont_umin		; LIMPIAR CUENTA DE UNIDADES DE MINUTO
    INCF    cont_dmin		; INCREMENTAR CUENTA DE DECENAS DE MINUTO
    MOVF    cont_dmin, W	; CARGAR CUENTA PARA REVISION DE OVERFLOW
    SUBLW   6			; VALOR DE OVERFLOW
    BTFSS   ZERO		; REVISION DE OVERFLOW
    GOTO    $+2			; SI NO HUBO OVERFLOW REVISAR BANDERA DE FIN DE DIA (CICLO 24H)
    GOTO    INC_UHOR		; SI HUBO OVERFLOW INCREMENTAR UNIDADES DE HORA
    BTFSC   the_end,0		; SI LA BANDERA NO ESTA ACTIVADA CONTINUAR
    GOTO    DAY_END		; SI LA BANDERA ESTA ACTIVADA IR A CUENTA PARA FINAL DEL DIA
    RETURN
    
INC_UHOR:			; INCREMENTO DE UNIDADES DE HORAS CON TMR1
    CLRF    cont_dmin		; LIMPIAR CUENTA DE DECENAS DE MINUTO
    INCF    cont_uhor		; INCREMENTAR CUENTA DE UNIDADES DE HORA
    MOVF    cont_uhor, W	; CARGAR CUENTA PARA REVISION DE OVERFLOW
    BTFSC   the_end, 0		; REVISAR BANDERA DE FIN DE DIA (CICLO 24H)
    GOTO    DAY_END		; IR A CUENTA PARA FINAL DEL DIA
    SUBLW   10			; VALOR DE OVERFLOW
    BTFSC   ZERO		; REVISION DE OVERFLOW
    GOTO    INC_DHOR		; SU HUBO OVERFLOW INCREMENTAR DECENAS DE HORA
    RETURN
    
    DAY_END:			; OVERFLOW PARA FINAL DE 24 HORAS
	MOVF	cont_uhor, W	; CARCAR CUENTA DE UNIDADES DE HORA
	SUBLW	4		; NUEVO VALOR DE OVERFLOW
	BTFSS	ZERO		; REVISION DE OVERFLOW
	GOTO	$+5		; SI NO HUBO OVERFLOW SALIR
	BCF	the_end, 0	; LIMPIAR BANDERA DE FINAL DE DIA
	CLRF    cont_uhor	; LIMPIAR CUENTA DE UNIDADES DE HORA
	CLRF    cont_dhor	; LIMPIAR CUENTA DE DECENAS DE HORA
	GOTO	CONT_MC		; IR A RESETEO GENERAL DE CUENTAS
    RETURN
    
INC_DHOR:			; INCREMENTO DE DECENAS DE HORAS CON TMR1
    CLRF    cont_uhor		; LIMPIAR CUENTA DE UNIDADES DE HORA
    INCF    cont_dhor		; INCREMENTAR CUENTA DE DECENAS DE HORA
    MOVF    cont_dhor, W	; CARGAR CUENTA PARA REVISION DE OVERFLOW
    SUBLW   2			; VALOR DE OVERFLOW
    BTFSC   ZERO		; REVISION DE OVERFLOW
    BSF	    the_end, 0		; SI HUBO OVERFLOW SETEAR BANDERA DE FIN DE DIA
    RETURN
    
CONT_MC:			; LIMPIEZA DE TODAS LAS CUENTAS DE TIEMPO
    CLRF    cont_useg		;	    |		|	    |
    CLRF    cont_dseg		;	    |		|	    |
    CLRF    cont_umin		;	    |		|	    |
    CLRF    cont_dmin		;	    |		|	    |
    CLRF    cont_uhor		;	    |		|	    |
    CLRF    cont_dhor		;	    |		|	    |
    RETURN 
    
DEC_ALARM:			; SUBRUTINA DE CUENTA REGRESIVA PARA REINICIO DE ALARMA
    INCF    cont_alarma		; INCREMENTAR CUENTA REGRESIVA PARA REINICIO DE ALARMA
    MOVF    cont_alarma, W	; CARGAR CUENTA PARA REVISAR SI SE HA LLEGADO A 1 MINUTO
    SUBLW   60			; REVISION DE CUENTA PARA 1 MINUTO
    BTFSS   ZERO		; SI SE LLEGO AL MINUTO APAGAR ALARMA
    GOTO    EXIT_DEC_ALARMA	; SI NO SE LLEGO AL MINUTO REGRESAR
    BCF	    alarma, 0		; LIMPIAR BANDERA DE ALARMA
    BCF	    PORTA, 5		; APAGAR BIT DE PODER PARA ALARMA
    EXIT_DEC_ALARMA:
    RETURN
 
//++++++++++++++++++++++++++INTERRUPCION TIMER 2++++++++++++++++++++++++++++++++
TMR2_INT:
    BCF	    TMR2IF		; LIMPIAR BANDERA DE INTERRUPCION DEL TMR2
    INCF    Cont_T2		; INCREMENTAR CUENTA DEL TMR2
    MOVF    Cont_T2, W		; CARGAR CUENTA DEL TMR2 AL REGISTRO W
    SUBLW   10			; USO DE RESTA PARA DETERMINAR SI LA CUENTA HA LLEGADO A 10X50mS QUE SERIA 500mS
    BTFSC   ZERO		; SI NO SE HA LLEGADO A LOS 500mS CONTINUAR
    GOTO    INC_LED		; SI SE LLEGO A LOS 500mS IR A SUBRUTINA DE ACTIVACION DEL LEDs
    RETURN       
    
INC_LED:			; ACTIVACION DE LEDs
    CLRF    Cont_T2		; LIMPIAR CUENTA DEL TMR2
    BTFSS   PORTA, 0		; REVISAR ESTAOD DEL PORTA BIT 0
    GOTO    $+3			; SI ESTA DESACTIVADO IR A ACTIVAR
    BCF	    PORTA, 0		; SI ESTA ACTIVADO DESACTIVAR EL BIT
    GOTO    $+2			; IR A SIGUIENTE INSTRUCCION
    BSF	    PORTA, 0		; SI ESTA DESACTIVADO ACTIVAR EL BIT
    BTFSS   PORTA, 1		; REVISAR ESTADO DEL PORTA BIT 1
    GOTO    $+3			; SI ESTA DESACTIVADO IR A ACTIVAR
    BCF	    PORTA, 1		; SI ESTA ACTIVADO DESACTIVAR EL BIT
    GOTO    $+2			; IR A SIGUIENTE INSTRUCCION
    BSF	    PORTA, 1		; SI ESTA DESACTIVADO ACTIVAR EL BIT
    BTFSS   estado, 2		; REVISAR SI SE ENCUENTRA EN EL ESTADO DE TIMER
    GOTO    CONTINUE		; SI NO CONTIUNAR
    BTFSC   edicion, 2		; REVISAR SI SE ESTA EDITANDO EL ESTADO DE TIMER
    GOTO    CONTINUE		; SI SE ESTA EDITANDO CONTINUAR
    CONT_TEST tmr_useg, tmr_dseg, tmr_umin, tmr_dmin, T_START, CONTINUE ; SI HAY UNA CUENTA CON VALOR DIFERENTE A 0
    ; INICIAR TIMER, DE LO CONTRARIO, CONTINUAR
    T_START:
    INCF    tmr_cont		; INCREMENTAR CUENTA DEL TIMER
    MOVF    tmr_cont, W		; CARGAR VALOR A W
    SUBLW   2			; USO DE RESTA PARA REVISION DE TIEMPO
    BTFSS   ZERO		; REVISAR SI SE HA LLEGADO A 2X500ms = 1S
    GOTO    CONTINUE		; SI NO HA PASADO 1S CONTINUAR
    CALL    TMR_DEC		; SI SE LLEGO A 1S LLAMAR SUBRUTINA DE DECREMENTO DEL TIMER
    CONTINUE:
    BTFSC   edicion, 0		; REVISAR SI SE ESTA EDITANDO EL ESTADO 0
    GOTO    LED_E0		; SI SE ESTA EDITANDO ACTIVAR INTERMITENCIA EN LED 0
    BTFSC   edicion, 1		; REVISAR SI SE ESTA EDITANDO EL ESTADO 1
    GOTO    LED_E1		; SI SE ESTA EDITANDO ACTIVAR INTERMITENCIA EN LED 1
    BTFSC   edicion, 2		; REVISAR SI SE ESTA EDITANDO EL ESTADO 2
    GOTO    LED_E2		; SI SE ESTA EDITANDO ACTIVAR INTERMITENCIA EN LED 2
    RETURN    
    
    LED_E0:			; INTERMITENCIA EN LED 0
	BTFSS   PORTA, 2	; REVISAR ESTADO DE PORTA BIT 2
	GOTO    $+3		; SI ESTA EN 0 IR A ACTIVACION
	BCF	PORTA, 2	; SI ESTA EN 1 CAMBIAR A 0
	GOTO    $+2		; SALIR DE SUBRUTINA
	BSF	PORTA, 2	; CAMBIAR A 1
    RETURN
    
    LED_E1:			; INTERMITENCIA EN LED 1
	BTFSS   PORTA, 3	; REVISAR ESTADO DE PORTA BIT 3
	GOTO    $+3		; SI ESTA EN 0 IR A ACTIVACION
	BCF	PORTA, 3	; SI ESTA EN 1 CAMBIAR A 0
	GOTO    $+2		; SALIR DE SUBRUTINA
	BSF	PORTA, 3	; CAMBIAR A 1
    RETURN
    
    LED_E2:			; INTERMITENCIA EN LED 1
	BTFSS   PORTA, 4	; REVISAR ESTADO DE PORTA BIT 4
	GOTO    $+3		; SI ESTA EN 0 IR A ACTIVACION
	BCF	PORTA, 4	; SI ESTA EN 1 CAMBIAR A 0
	GOTO    $+2		; SALIR DE SUBRUTINA
	BSF	PORTA, 4	; CAMBIAR A 1
    RETURN

//++++++++++++++++++++++++FUNCION CUENTA REGRESIVA TIMER++++++++++++++++++++++++   
TMR_DEC:			; SUBRUTINA DE DECREMENTO DE ALARMA
    CLRF    tmr_cont		; LIMPIAR CUENTA DE TIMER
    BSF	    tmr_var, 0		; ACTIVAR BANDERA DE TIMER
    DECF    tmr_useg		; DISMINUIR SEGUNDOS DE TIMER
    CONT_TEST tmr_useg, tmr_dseg, tmr_umin, tmr_dmin, END_TMR_DEC, ALARM_START; REVISAR SI
    ; TODAS LAS VARIABLES SE ENCUENTRAN EN 0
    GOTO    END_TMR_DEC		; SI NO SE ENCUENTRAN EN 0 SALIR DE SUBRUTINA
    
    ALARM_START:		; INICIO DE ALARMA
    BCF	    tmr_var, 0		; DESACTIVAR BANDERA DE TIMER (YA NO SE ESTA CONTANDO)
    BSF	    alarma, 0		; ACTIVAR BANDERA DE ALARMA
    BSF	    PORTA, 5		; ACTIVAR PIN DE PODER ALARMA
    
    END_TMR_DEC:
    RETURN
    
//---------------------------INDICE DISPLAY 7SEG--------------------------------
PSECT HEX_INDEX, class = CODE, abs, delta = 2
ORG 200h			; posición 200h para el codigo
 
HEX_INDEX:
    CLRF PCLATH
    BSF PCLATH, 1		; PCLATH en 01
    ANDLW 0x0F
    ADDWF PCL			; PC = PCLATH + PCL | SUMAR W CON PCL PARA INDICAR POSICIÓN EN PC
    RETLW 00111111B		; 0
    RETLW 00000110B		; 1
    RETLW 01011011B		; 2
    RETLW 01001111B		; 3
    RETLW 01100110B		; 4
    RETLW 01101101B		; 5
    RETLW 01111101B		; 6
    RETLW 00000111B		; 7
    RETLW 01111111B		; 8 
    RETLW 01101111B		; 9
    RETLW 01110111B		; A
    RETLW 01111100B		; b
    RETLW 00111001B		; C
    RETLW 01011110B		; D
    RETLW 01111001B		; C
    RETLW 01110001B		; F   
    
//------------------------------MAIN CONFIG-------------------------------------
main:
    CALL    IO_CONFIG		; INICIAR CONFIGURACION DE PINES
    CALL    CLK_CONFIG		; INICIAR CONFIGURACION DE RELOJ
    CALL    TMR0_CONFIG		; INICIAR CONFIGURACION DEL TMR0
    CALL    TMR1_CONFIG		; INICIAR CONFIGURACION DEL TMR1
    CALL    TMR2_CONFIG		; INICIAR CONFIGURACION DEL TMR2
    CALL    IOCRB_CONFIG	; INICIAR CONFIGURACION DE IOC EN PORTB
    CALL    INT_CONFIG		; INICIAR CONFIGURACION DE INTERRUPCIONES
    BANKSEL PORTA

LOOP:
    BTFSC   estado, 0		; REVISAR SI ESTA ACTIVO EL ESTADO 0
    GOTO    DISP_HORA		; SI LO ESTA ACTIVAR DISPLAY PARA HROA
    BTFSC   estado, 1		; REVISAR SI ESTA ACTIVO EL ESTADO 1
    GOTO    DISP_FECHA		; SI LO ESTA ACTIVAR DISPLAY PARA FECHA
    BTFSC   estado, 2		; REVISAR SI ESTA ACTIVO EL ESTADO 2
    GOTO    DISP_TIMER		; SI LO ESTA ACTIVAR DISPLAY PARA TIMER
    GOTO    LOOP
    
    DISP_HORA:
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; CARGAR VALORES DE HORA A DISPLAYS
    GOTO LOOP
    
    DISP_FECHA:
;    SET_DISPLAY (FECHA NO IMPLEMENTADA)
    GOTO LOOP
    
    DISP_TIMER:
    SET_DISPLAY tmr_useg, tmr_dseg, tmr_umin, tmr_dmin	    ; CARGAR VALORES DE TIMER A DISPLAYS
    BTFSS   tmr_var, 0					    ; REVISAR SI ESTA ACTIVADO EL TIMER
    GOTO    EXIT_DISP_TIMER				    ; SI NO LO ESTA SALIR MODO DE DISPLAY DEL TIMER
    DEC_UF_TEST	0xFF, 9, tmr_useg, EXIT_DISP_TIMER	    ; REVISION DE UNDERFLOW PARA TIMER SEG/MIN (UNIDADES/DECENAS)
    DECF    tmr_dseg					    ;		|		|		|		|
    DEC_UF_TEST	0xFF, 5, tmr_useg, EXIT_DISP_TIMER	    ;		|		|		|		|
    DECF    tmr_umin					    ;		|		|		|		|
    DEC_UF_TEST	0xFF, 9, tmr_umin, EXIT_DISP_TIMER	    ;		|		|		|		|
    DECF    tmr_dmin					    ;		|		|		|		|
    DEC_UF_TEST	0xFF, 0, tmr_dmin, EXIT_DISP_TIMER	    ;		|		|		|		|
    
    EXIT_DISP_TIMER:
    GOTO LOOP
    
//---------------------------CONFIG SUBRUTINES----------------------------------
CLK_CONFIG:
    BANKSEL OSCCON		; SELECCIONAR CONFIGURADOR DEL OSCILADOR
    BSF	    SCS			; USAR OSCILADOR INTERNO PARA RELOJ DE SISTEMA
    BCF	    IRCF0		; BIT 4 DE OSCCON EN 0
    BSF	    IRCF1		; BIT 5 DE OSCCON EN 1
    BSF	    IRCF2		; BIT 6 DE OSCCON EN 1
    //OSCCON 110 -> 4MHz RELOJ INTERNO
    RETURN
    
IOCRB_CONFIG:
    BANKSEL IOCB		; SELECCIONAR BANCO DONDE SE ENCUENTRA IOCB
    BSF	    IOCB, 0		; ACTIVAR IOCB PARA PUSHBOTTON 1
    BSF	    IOCB, 1		; ACTIVAR IOCB PARA PUSHBOTTON 2
    BSF	    IOCB, 2		; ACTIVAR IOCB PARA PUSHBOTTON 3
    BSF	    IOCB, 3		; ACTIVAR IOCB PARA PUSHBOTTON 4
    
    BANKSEL PORTA		; SELECCIONAR EL BANCO 0
    MOVF    PORTB, W		; CARGAR EL VALOR DEL PORTB A W PARA CORREGIR MISMATCH
    BCF	    RBIF		; LIMPIAR BANDERA DE INTERRUPCIÓN EN PORTB
    RETURN    
    
IO_CONFIG:
    BANKSEL ANSEL
    CLRF    ANSEL
    CLRF    ANSELH		; I/O digitales
    
    BANKSEL TRISC
    CLRF    TRISC		; PORTC COMO SALIDA
    MOVLW   0xF0
    MOVWF   TRISD		; PORTD 4 PINES PARA MULTIPLEX
    MOVLW   0xFC
    MOVWF   TRISE		; PORTE 2 PINES PARA ESTADOS
    BSF	    TRISB, 0		; PORTB PIN0 COMO INPUT
    BSF	    TRISB, 1		; PORTB PIN1 COMO INPUT
    BSF	    TRISB, 2		; PORTB PIN2 COMO INPUT
    BSF	    TRISB, 3		; PORTB PIN3 COMO INPUT
    CLRF    TRISA		; PORTA COMO SALIDA
    
    BCF	    OPTION_REG, 7	; LIMPIAR RBPU PARA DESBLOQUEAR EL MODO PULL-UP EN PORTB
    BSF	    WPUB, 0		; SETEAR WPUB PARA ATVICAR EL PIN 0 DEL PORTB COMO WEAK PULL-UP
    BSF	    WPUB, 1		; SETEAR WPUB PARA ACTIVAR EL PIN 1 DEL PORTB COMO WEAK PULL-UP
    BSF	    WPUB, 2		; SETEAR WPUB PARA ACTIVAR EL PIN 2 DEL PORTB COMO WEAK PULL-UP
    BSF	    WPUB, 3		; SETEAR WPUB PARA ACTIVAR EL PIN 3 DEL PORTB COMO WEAK PULL-UP
    
    BANKSEL PORTC		; SELECCIONAR BANCO 0
    CLRF    PORTC		; LIMPIEZA DE PUERTOS 
    CLRF    PORTD		; |	   |	    |
    CLRF    PORTE		; |	   |	    |
    CLRF    PORTA		; |	   |	    |
    CLRF    bandera		; LIMPIEZA DE BANDERAS/VARIABLES
    CLRF    L_display		; |	   |	    |		|
    CLRF    R_display		; |	   |	    |		|
    CLRF    alarma		; |	   |	    |		|
    CLRF    cont_alarma		; |	   |	    |		|
    CLRF    edicion		; |	   |	    |		|
    CLRF    estado		; |	   |	    |		|
    CLRF    inc_flag		; |	   |	    |		|
    CLRF    cont_useg		; |	   |	    |		|
    CLRF    cont_dseg		; |	   |	    |		|
    CLRF    cont_umin		; |	   |	    |		|
    CLRF    cont_dmin		; |	   |	    |		|
    CLRF    cont_uhor		; |	   |	    |		|
    CLRF    cont_dhor		; |	   |	    |		|
    CLRF    tmr_var		; |	   |	    |		|
    CLRF    tmr_cont		; |	   |	    |		|
    CLRF    tmr_useg		; |	   |	    |		|
    CLRF    tmr_dseg		; |	   |	    |		|
    CLRF    tmr_umin		; |	   |	    |		|
    CLRF    tmr_dmin		; |	   |	    |		|
    CLRF    Cont_T2		; |	   |	    |		|
    CLRF    Cont_Hora		; |	   |	    |		|
    CLRF    edit		; |	   |	    |		|
    CLRF    the_end		; |	   |	    |		|
    RETURN    

TMR0_CONFIG:
    BANKSEL OPTION_REG		; SELECCIONAR BANCO 1 PARA TMR0 CONFIG
    BCF	    T0CS		; USO DE RELOJ INTERNO
    BCF	    PSA			; PRESCALER A TMR0
    BSF	    PS2			; PRESCALER EN 256
    BSF	    PS1
    BSF	    PS0
    
    BANKSEL TMR0		; SELECIONAR EL BANCO 
    MOVLW   250			; N=256-[(2mS*4MHz)/(4x256)]=248 redondeado es: 250
    MOVWF   TMR0		; CARGAR VALOR DE N AL TMR0 
    BCF	    T0IF		; LIMPIAR BANDERA DE INTERRUPCION DE TMR0
    RETURN
    
TMR1_CONFIG:
    BANKSEL T1CON		; SELECIONAR EL BANCO DEL T1CON
    BCF	    TMR1GE		; ACTIVAR CUENTA PERPETUA EN TMR1
    BSF	    T1CKPS1		; PRESCALER EN 1:8
    BSF	    T1CKPS0		; |	    |	|
    BCF	    T1OSCEN		; MODO DE BAJA POTENCIA ACTIVADO
    BCF	    TMR1CS		; USO DEL RELOJ INTERNO
    BSF	    TMR1ON		; ENCENDIDO DEL TMR1
    
    TMR1_RESET 0x0B, 0xDC	; REINICIO DEL TMR1 EN 500mS
    ; VALOR A CARGAR: 65536-(0.5)/[8(1/1x10^6)]=3036d=0x0BDC
    RETURN    
    
TMR2_CONFIG:
    BANKSEL PR2			; SELECCIONAR BANCO DEL PR2
    MOVLW   195			; CARGAR VALOR CALCULADO PARA INTERRUPCIONES DE 50mS EN EL TMR2 AL REGISTRO W
    MOVWF   PR2			; MOVER VALOR AL PR2
    
    BANKSEL T2CON		; SELECCIONAR EL BANCO DEL T2CON
    BSF	    T2CKPS1		; PRESCALER EN 1:16
    BSF	    T2CKPS0		
    
    BSF	    TOUTPS3		; POSTSCALER EN 1:16
    BSF	    TOUTPS2		
    BSF	    TOUTPS1
    BSF	    TOUTPS0
    BSF	    TMR2ON		; ENCENDIDO DEL TMR2
    RETURN    
    
INT_CONFIG:
    BANKSEL PIE1		; SELECCIONAR BANCO DEL PIE1
    BSF	    TMR1IE		; HABILITAR INTERRUPCIONES EN TMR1
    BSF	    TMR2IE		; HABILITAR INTERRUPCIONES EN TMR2
    
    BANKSEL INTCON		; SELECCIONAR BANCO DEL INTCON
    BSF	    PEIE		; HABILITAR INTERRUPCIONES EN PERIFERICOS
    BSF	    GIE			; ACTIVAR INTERRUPCIONES GLOBALES
    BSF	    RBIE		; ACTIVAR CAMBIO DE INTERRUPCIONES EN PORTB
    BCF	    RBIF		; LIMPIAR BANDERA DE CAMBIO EN PORTB POR SEGURIDAD
    BSF	    T0IE		; HABILITAR INTERRUPCIONES EN TMR0
    BCF	    T0IF		; LIMPIAR BANDERA DE INTERRUPCIONES EN TMR0
    BCF	    TMR1IF		; LIMPIAR BANDERA DE INTERRUPCIONES EN TMR1
    BCF	    TMR2IF		; LIMPIAR BANDERA DE INTERRUPCIONES EN TMR2
    RETURN
    
//-------------------------------SPST SUBRUTINES--------------------------------    
FMS_CONFIG:
    BTFSC   PORTB, 0		; ANTIRREBOTES PARA PORTB PIN0
    GOTO    EXIT_FMS_CONFIG	; SI NO SE HA ESTABILIZADO NO REALIZAR INSTRUCCIONES
    BTFSC   edicion, 3		; REVISAR SI SE ESTA EN MODO DE EDICION
    GOTO    EDITANDO		; SI SE ESTA EN DICHO MODO, ACCEDER SECCION PARA EDICION DE FUNCIONES
    BTFSC   alarma, 0		; REVISAR SI ESTA PRENDIDA LA ALARMA
    CALL    ALARM_OFF		; SI ESTA PRENDIDA, IR A SUBRUTINA DE APAGADO DE ALARMA
    INCF    PORTE		; INCREMENTAR PORTE PARA REGISTRO DE ESTADOS
    BTFSS   PORTE, 0		; REVISAR SI EL BIT0 DEL PORTE ESTA EN 0
    CALL    AJUSTE_ESTADO	; SI ESTA EN 0 IR A AJUSTE DE ESTADO PARA SALIR DEL ESTADO 00
    MOVF    PORTE, W		; SI NO ESTABA EN 0, REVISAR SI EL VALOR DE PORTE ES 1
    SUBLW   1			; USO DE RESTA PARA REVISAR SI VALOR DEL PORTE ES 1
    BTFSC   ZERO		; BANDERA DE ZERO PARA DETERMINAR EL ESTADO AL QUE SE DEBE ACCEDER
    CALL    MODO_HORA		; SI SE ESTABA EN 1 IR A MODO HORA (PRIMER ESTADO)
    MOVF    PORTE, W		; SI NO SE ESTABA EN 1 REVISAR EL VALOR DEL PUERTO NUEVAMENTE
    SUBLW   2			; USO DE RESTA PARA REVISAR SI EL VALOR DE PORTE ES 2
    BTFSC   ZERO		; BANDERA DE ZERO PARA DETERMINAR EL ESTADO AL QUE SE DEBE ACCEDER
    CALL    MODO_FECHA		; SI SE ESTABA EN 2 IR A MODO FECHA (SEGUNDO ESTADO)
    MOVF    PORTE, W		; SI NO SE ESTABA EN 2 REVISAR EL VALOR DEL PUERTO NUEVAMENTE
    SUBLW   3			; USO DE RESTA PARA REVISAR SI EL VALOR DE PORTE ES 3
    BTFSC   ZERO		; BANDERA DE ZERO PARA DETERMINAR EL ESTADO AL QUE SE DEBE ACCEDER
    CALL    MODO_TIMER		; SI SE ESTABA EN 3 IR A MODO TIMER (TERCER Y ULTIMO ESTADO)
    RETURN
    EDITANDO:			; SI SE ESTA EN MODO DE EDICION
    BTFSS   edit, 0		; BANDERA "edit" USADA PARA EDITAR HORAS/MINUTOS O MINUTOS/SEGUNDOS
    GOTO    $+3			
    BCF	    edit, 0		; SI LA BANDERA ESTA EN 0 EDITAR TIEMPO DE MENOR DENOMINACION
    GOTO    $+2
    BSF	    edit, 0		; SI LA BANDERA ESTA EN 1 EDITAR TIEMPO DE MAYOR DENOMINACION
    EXIT_FMS_CONFIG:
    RETURN
    
EDIT_CONFIG:
    BTFSC   estado, 0		; REVISAR LA BANDERA DE ESTADO PARA DETERMINAR EL ESTADO A MODIFICAR
    GOTO    ESTADO_0		; MODIFICAR ESTADO 0
    BTFSC   estado, 1
    GOTO    ESTADO_1		; MODIFICAR ESTADO 1
    BTFSC   estado, 2
    GOTO    ESTADO_2		; MODIFICAR ESTADO 2
    RETURN
    
    ESTADO_0:
	BTFSS   edicion, 0	; PRIMERO SE REVISA SI YA SE ESTABA EN MODO DE EDICION PARA ESTADO 0
	GOTO    $+5		; SI NO SE ESTABA EN MODO DE EDICION, SE ACTIVAN LAS BANDERAS NECESARIAS
	BCF	edicion, 0	; SI SE ESTABA EN EL MODO DE EDICION SE LIMPIAN LAS BANDERAS
	BCF	edicion, 3	; PARA SALIR DEL MODO DE EDICION
	BSF	PORTA, 2	; SE ENCIENDE EL LED PARA QUE ESTE QUEDE FIJO
	GOTO    $+3		; SE SALTAN LAS SIGUIENTES DOS INSTRUCCIONES
	BSF	edicion, 0	; BANDERA QUE INDICA QUE SE ESTA EDITANDO ESTADO 0
	BSF	edicion, 3	; BANDERA QUE INDICA QUE SE ESTA EN MODO DE EDICION
    RETURN

    ESTADO_1:
	BTFSS   edicion, 1	; PRIMERO SE REVISA SI YA SE ESTABA EN MODO DE EDICION PARA ESTADO 1
	GOTO    $+5		; SI NO SE ESTABA EN MODO DE EDICION, SE ACTIVAN LAS BANDERAS NECESARIAS
	BCF	edicion, 1	; SI SE ESTABA EN EL MODO DE EDICION SE LIMPIAN LAS BANDERAS
	BCF	edicion, 3	; PARA SALIR DEL MODO DE EDICION
	BSF	PORTA, 3	; SE ENCIENDE EL LED PARA QUE ESTE QUEDE FIJO
	GOTO    $+3		; SE SALTAN LAS SIGUIENTES DOS INSTRUCCIONES
	BSF	edicion, 1	; BANDERA QUE INDICA QUE SE ESTA EDITANDO ESTADO 1
	BSF	edicion, 3	; BANDERA QUE INDICA QUE SE ESTA EN MODO DE EDICION
    RETURN

    ESTADO_2:
	BTFSS   edicion, 2	; PRIMERO SE REVISA SI YA SE ESTABA EN MODO DE EDICION PARA ESTADO 2
	GOTO    $+5		; SI NO SE ESTABA EN MODO DE EDICION, SE ACTIVAN LAS BANDERAS NECESARIAS
	BCF	edicion, 2	; SI SE ESTABA EN EL MODO DE EDICION SE LIMPIAN LAS BANDERAS
	BCF	edicion, 3	; PARA SALIR DEL MODO DE EDICION
	BSF	PORTA, 4	; SE ENCIENDE EL LED PARA QUE ESTE QUEDE FIJO
	GOTO    $+3		; SE SALTAN LAS SIGUIENTES DOS INSTRUCCIONES
	BSF	edicion, 2	; BANDERA QUE INDICA QUE SE ESTA EDITANDO ESTADO 2
	BSF	edicion, 3	; BANDERA QUE INDICA QUE SE ESTA EN MODO DE EDICION
    RETURN
    
AJUSTE_ESTADO:
    BTFSS   PORTE, 1		; REVISAR SI EL SEGUNDO BIT DE PORTE ES 0 TAMBIEN
    BSF	    PORTE, 0		; SI LO ES, SETEARLO A 1 DE MANERA QUE NO SE PUEDA
    RETURN			; ACCEDER EL ESTADO 00 MAS QUE AL INICIO
    
INC_CONFIG:
    INC_MIN0:			; INCREMENTO MANUAL DE MINUTOS PARA MODO 0 (HORA)
    BTFSC   edit, 0		; REVISAR BANDERA DE MODO DE EDICION, SI EN 0 EDITAR MINUTOS
    GOTO    INC_HORA0		; SI EN 1 IR A EDICION DE HORAS
    BTFSS   edicion, 0		; REVISAR BANDERA DE EDICION DE ESTADO, SI EN 1 SE ESTA EDITANDO EL ESTADO 0
    GOTO    INC_SEG2		; SI EN 0 REVISAR SIGUIENTE ESTADO
    INCF    cont_umin		; INCREMENTO DE CUENTA DE UNIDADES DE MINUTOS
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    INC_OF_TEST 10, cont_umin, END_INC			    ; REVISAR OVERFLOW
    INCF    cont_dmin		; INCREMENTO DE CUENTA DE DECENAS DE MINUTOS
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    INC_OF_TEST 6, cont_dmin, END_INC			    ; REVISAR OVERFLOW
    CLRF    cont_umin		; LIMPIAR CUENTA DE UNIDADES DE MINUTO
    CLRF    cont_dmin		; LIMPIAR CUENTA DE DECENAS DE MINUTO
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAU
    INC_HORA0:			; INCREMENTO MANUAL DE HORAS PARA MODO 0 (HORA)
    BTFSS   edit, 0		; REVISAR BANDERA DE MODO DE EDICION, SI EN 1 EDITAR HORAS
    GOTO    INC_MIN0		; SI EN 0 IR A EDICION DE MINUTOS
    BTFSS   edicion, 0		; REVISAR BANDERA DE EDICION DE ESTADO, SI EN 1 SE ESTA EDITANDO EL ESTADO 0
    GOTO    INC_MIN2		; SI EN 0 REVISAR SIGUIENTE ESTADO
    INCF    cont_uhor		; INCREMENTO DE CUENTA DE UNIDADES DE HORA
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    BTFSC   the_end, 0		; REVISAR BANDERA DE FIN DE DIA
    GOTO    HORA_END		; SI ACTIVADA IR A REVISION DE OVERFLOW DE FIN DE DIA
    INC_OF_TEST 10, cont_uhor, END_INC			    ; REVISAR OVERFLOW
    INCF    cont_dhor		; INCREMENTO DE CUENTA DE DECENAS DE HOAR
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    MOVF    cont_dhor, W	; CARGAR CUENTA DE DECENAS DE HORA PARA REVISAR OVERFLOW
    SUBLW   2			; VALOR DE OVERFLOW
    BTFSC   ZERO		; REVISION DE OVERFLOW
    BSF	    the_end, 0		; SI HAY OVERFLOW ACTIVAR BANDERA DE FIN DE DIA
    GOTO    END_INC		; SI NO HAY OVERFLOW SALIR
    HORA_END:			; FIN DE DIA
    MOVF    cont_uhor, W	; CARGAR CUENTA DE UNIDADES DE HORA PARA REVISAR OVERFLOW
    SUBLW   4			; VALOR DE OVERFLOW
    BTFSS   ZERO		; REVISION DE OVERFLOW
    GOTO    END_INC		; SI NO HUBO OVERFLOW SALIR
    BCF	    the_end, 0		; SI HUBO OVERFLOW LIMPIAR BANDERA DE FIN DE DIA
    CLRF    cont_dhor		; REINICIAR CUENTA EN HORAS
    CLRF    cont_uhor		; |	    |		|
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    GOTO END_INC		; SALIR
    
    INC_SEG2:			; INCREMENTO MANUAL DE SEGUNDOS PARA MODO 2 (TIMER)
    BTFSC   edit, 0		; REVISAR BANDERA DE MODO DE EDICION, SI EN 0 EDITAR SEGUNDOS
    GOTO    INC_MIN2		; SI EN 1 IR A EDICION DE MINUTOS
    BTFSS   edicion, 2		; REVISAR BANDERA DE EDICION DE ESTADO, SI EN 1 SE ESTA EDITANDO EL ESTADO 2
    GOTO    END_INC		; SALIR
    INCF    tmr_useg		; INCREMENTO DE UNIDADES DE SEGUNDO
    SET_DISPLAY tmr_useg, tmr_dseg, tmr_umin, tmr_dmin	; ACTUALIZAR DISPLAY
    INC_OF_TEST 10, tmr_useg, END_INC			; REVISAR OVERFLOW
    INCF    tmr_dseg		; INCREMENTO DE DECENAS DE SEGUNDO
    SET_DISPLAY tmr_useg, tmr_dseg, tmr_umin, tmr_dmin	; ACTUALIZAR DISPLAY
    INC_OF_TEST 6, tmr_dseg, END_INC			; REVISAR OVERFLOW
    CLRF    tmr_useg		; LIMPIAR CUENTAS
    CLRF    tmr_dseg		;   |	    |
    SET_DISPLAY tmr_useg, tmr_dseg, tmr_umin, tmr_dmin	; ACTUALIZAR DISPLAY
    INC_MIN2:			; INCREMENTO MANUAL DE MINUTOS PARA MODO 2 (TIMER)
    BTFSS   edit, 0		; REVISAR BANDERA DE MODO DE EDICION, SI EN 1 EDITAR MINUTOS
    GOTO    INC_SEG2		; SI EN 0 IR A EDICION DE SEGUNDOS
    INCF    tmr_umin		; INCREMENTO DE UNIDADES DE MINUTO
    SET_DISPLAY tmr_useg, tmr_dseg, tmr_umin, tmr_dmin	; ACTUALIZAR DISPLAY
    INC_OF_TEST 10, tmr_umin, END_INC			; REVISAR OVERFLOW
    INCF    tmr_dmin		; INCREMENTO DE DECENAS DE MINUTO
    SET_DISPLAY tmr_useg, tmr_dseg, tmr_umin, tmr_dmin	; ACTUALIZAR DISPLAY
    INC_OF_TEST 10, tmr_dmin, END_INC			; REVISAR OVERFLOW
    CLRF    tmr_umin		; LIMPIAR CUENTAS
    CLRF    tmr_dmin		;   |	    |
    
    END_INC:
    RETURN
    
DEC_CONFIG:
    DEC_MIN0:			; DECREMENTO MANUAL DE MINUTOS PARA MODO 0 (HORA)
    BTFSC   edit, 0		; REVISAR BANDERA DE MODO DE EDICION, SI EN 0 EDITAR MINUTOS
    GOTO    DEC_HORA0		; SI EN 1 IR A EDICION DE HORAS
    BTFSS   edicion, 0		; REVISAR BANDERA DE EDICION DE ESTADO, SI EN 1 SE ESTA EDITANDO EL ESTADO 0
    GOTO    DEC_SEG2		; SI EN 0 REVISAR SIGUIENTE ESTADO
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    MOVF    cont_dmin, W	; CARGAR CUENTA DE DECENAS DE MINUTOS PARA REVISAR ESTADO
    SUBLW   0			; VALOR A REVISAR
    BTFSS   ZERO		; REVISAR IGUALDAD
    GOTO    TAG1		; SI ESTABA EN 0 IR A POSICION DE TAG1
    MOVF    cont_umin, W	; CARGAR CUENTA DE UNIDADES DE MINUTOS PARA REVISAR ESTADO
    SUBLW   0			; VALOR A REVISAR
    BTFSS   ZERO		; REVISAR IGUALDAD
    GOTO    TAG1		; SI ESTABA EN 0 IR A POSICION DE TAG1
    DECF    cont_umin		; DECREMENTAR CUENTA DE UNIDADES DE MINUTO
    MOVF    cont_umin, W	; CARGAR CUENTA DE UNIDADES DE MINUTO PARA REVISAR UNDERFLOW
    SUBLW   0xFF		; VALOR DE UNDERFLOW
    BTFSS   ZERO		; REVISION DE UNDERFLOW
    GOTO    TAG1		; SI NO HUBO UNDERFLOW IR A POSICION DE TAG1
    MOVLW   9			; SI HUBO UNDERFLOW REEMPLAZAR VALOR DE UNIDADES POR 9
    MOVWF   cont_umin		; CARGAR 9 A VARIABLE DE CUENTA DE UNIDADES DE MINUTO
    MOVLW   5			; REEMPLAZAR VALOR DE DECENAS DE MINUTO POR 5
    MOVWF   cont_dmin		; CARGAR 5 A VARIABLE DE CUENTA DE DECENAS DE MINUTO
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    RETURN			; SALIR
    TAG1:
    DECF    cont_umin		; DECREMENTAR CUENTA DE UNIDADES DE MINUTO
    MOVF    cont_umin, W	; CARGAR CUENTA DE UNUIDADES DE MINUTO PARA REVISAR UNDERFLOW
    SUBLW   0xFF		; VALOR DE UNDERFLOW
    BTFSC   ZERO		; REVISION DE UNDERFLOW
    GOTO    RESET1		; SI HUBO UNDERFLOW IR A RESETEO
    GOTO    END_DEC		; SI NO HUBO UNDERFLOW SALIR
    RESET1:
    MOVLW   9			; CARGAR NUEVO VALOR DE CUENTA DE UNIDADES DE MINUTO
    MOVWF   cont_umin		; CARGAR 9 A LA VARIABLE DE CUENTA DE UNIDADES DE MINUTO
    DECF    cont_dmin		; DECREMENTAR CUENTA DE DECENAS DE MINUTO
    MOVF    cont_dmin, W	; CARGAR CUENTA DE DECENAS DE MINUTO PARA REVISAR UNDERFLOW
    SUBLW   0xFF		; VALOR DE UNDERFLOW
    BTFSC   ZERO		; REVISION DE UNDEFLOW
    GOTO    TAG2		; SI HUBO UNDERFLOW IR A POSICION DE TAG2
    GOTO    END_DEC		; SI NO HUBO UNDERFLOW SALIR
    TAG2:
    MOVLW   5			; CARGAR NUEVO VALOR DE CUENTA DE DECENAS DE MINUTO
    MOVWF   cont_dmin		; CARGAR 5 A LA VARIABLE DE CUENTA DE DECENAS DE MINUTO
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    GOTO    DEC_MIN0		; SALIR
    DEC_HORA0:			; DECREMENTO MANUAL DE HORAS PARA MODO 0 (HORA)
    BTFSS   edit, 0		; REVISAR BANDERA DE MODO DE EDICION, SI EN 1 EDITAR HORAS
    GOTO    DEC_MIN0		; SI EN 0 IR A EDICION DE MINUTOS
    BTFSS   edicion, 0		; REVISAR BANDERA DE EDICION DE ESTADO, SI EN 1 SE ESTA EDITANDO EL ESTADO 0
    GOTO    DEC_SEG2		; SI EN 0 REVISAR SIGUIENTE ESTADO
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    MOVF    cont_dhor, W	; CARGAR CUENTA DE DECENAS DE HORA PARA REVISAR ESTADO
    SUBLW   0			; VALOR A REVISAR
    BTFSS   ZERO		; REVISAR IGUALDAD
    GOTO    TAG3		; SI ESTABA EN 0 IR A POSICION DE TAG3
    MOVF    cont_uhor, W	; CARGAR CUENTA DE UNIDADES DE HORA PARA REVISAR ESTADO
    SUBLW   0			; VALOR A REVISAR
    BTFSS   ZERO		; REVISAR IGUALDAD
    GOTO    TAG3		; SI ESTABA EN 0 IR A POSICION DE TAG3
    DECF    cont_uhor		; DECREMENTAR CUENTA DE UNIDADES DE HORA
    MOVF    cont_uhor, W	; CARGAR CUENTA DE UNIDADES DE HORA PARA REVISAR UNDERFLOW
    SUBLW   0xFF		; VALOR DE UNDERFLOW
    BTFSS   ZERO		; REVISION DE UNDERFLOW
    GOTO    TAG3		; SI NO HUBO UNDERFLOW IR A POSICION DE TAG2
    MOVLW   3			; SI HUBO UNDERFLOW REEMPLAZAR VALOR DE UNIDADES POR 3
    MOVWF   cont_uhor		; CARGAR 3 A VARIABLE DE CUENTA DE UNIDADES DE MINUTO
    MOVLW   2			; REEMPLAZAR VALOR DE DECENAS DE HORA POR 2
    MOVWF   cont_dhor		; CARGAR 5 A VARIABLE DE CUENTA DE DECENAS DE HORA
    BSF	    the_end, 0		; SETEAR BANDERA DE FIN DE DIA
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    RETURN			; SALIR
    TAG3:
    BCF	    the_end, 0		; LIMPIAR BANDERA DE FIN DE DIA
    DECF    cont_uhor		; DECREMENTAR UNIDADES DE HORA
    MOVF    cont_uhor, W	; CARGAR UNIDADES DE HORA PARA REVISAR UNDERFLOW
    SUBLW   0xFF		; VALOR DE UNDERFLOW
    BTFSC   ZERO		; REVISION DE UNDERFLOW
    GOTO    RESET2		; SI HUBO UNDERFLOW IR A POSICION DE RESETEO 2
    GOTO    END_DEC		; SI NO HUBO UNDERFLOW SALIR
    RESET2:
    MOVLW   9			; CARGAR 9 A VARIABLE DE UNIDADES DE HORA
    MOVWF   cont_uhor		; MOVER NUEVO VALOR A CUENTA DE UNIDADES DE HORA
    DECF    cont_dhor		; DECREMENTAR DECENAS DE HORA
    MOVF    cont_dhor, W	; CARGAR DECENAS DE HORA PARA REVISAR UNDERFLOW
    SUBLW   0xFF		; VALOR DE UNDERFLOW
    BTFSC   ZERO		; REVISION DE UNDERFLOW
    GOTO    TAG4		; SI HUBO UNDERFLOW IR A POSICION DE TAG4
    GOTO    END_DEC		; SI NO HUBO UNDERFLOW SALIR
    TAG4:
    BCF	    the_end, 0		; LIMPIAR BANDERA DE FINAL DE DIA
    MOVLW   2			; CARGAR 9 A DECENAS DE HORA
    MOVWF   cont_dhor		; MOVER NUEVO VALOR A CUENTA DE DECENAS DE HORA
    SET_DISPLAY cont_umin, cont_dmin, cont_uhor, cont_dhor  ; ACTUALIZAR DISPLAY
    GOTO    DEC_MIN0		; IR A DECREMENTO DE MINUTOS MANUAL PARA MODO 0
    
    
    DEC_SEG2:			; DECREMENTO MANUAL DE SEGUNDOS PARA MODO 2 (TIMER)
    BTFSC   edit, 0		; REVISAR BANDERA DE MODO DE EDICION, SI EN 0 EDITAR SEGUNDOS
    GOTO    DEC_MIN2		; SI EN 1 IR A EDICION DE MINUTOS 
    BTFSS   edicion, 2		; REVISAR BANDERA DE EDICION DE ESTADO, SI EN 1 SE ESTA EDITANDO EL ESTADO 2
    GOTO    END_DEC		; SALIR
    SET_DISPLAY tmr_useg, tmr_dseg, tmr_umin, tmr_dmin	; ACTUALIZAR DISPLAY
    DECF    tmr_useg		; DECREMENTAR UNIDADES DE SEGUNDO
    DEC_UF_TEST 0xFF, 10, tmr_useg, END_DEC ; REVISION DE UNDERFLOW PARA CUENTA DE UNIDADES DE SEGUNDO
    DECF    tmr_dseg		; DECREMENTAR DECENAS DE SEGUNDO
    DEC_UF_TEST 0xFF, 5, tmr_dseg, END_DEC  ; REVISION DE UNDERFLOW PARA CUENTA DE DECENAS DE SEGUNDO
    SET_DISPLAY tmr_useg, tmr_dseg, tmr_umin, tmr_dmin	; ACTUALIZAR DISPLAY
    DEC_MIN2:
    BTFSS   edit, 0		; REVISAR BANDERA DE MODO DE EDICION, SI EN 1 EDITAR SEGUNDOS
    GOTO    DEC_SEG2		; SI EN 0 IR A EDICION DE MINUTOS 
    BTFSS   edicion, 2		; REVISAR BANDERA DE EDICION DE ESTADO, SI EN 1 SE ESTA EDITANDO EL ESTADO 2
    GOTO    END_DEC		; SALIR
    SET_DISPLAY tmr_useg, tmr_dseg, tmr_umin, tmr_dmin	; ACTUALIZAR DISPLAY
    DECF    tmr_umin		; DECREMENTAR UNIDADES DE MINUTO
    DEC_UF_TEST 0xFF, 9, tmr_umin, END_DEC  ; REVISION DE UNDERFLOW PARA CUENTA DE UNIDADES DE MINUTO
    DECF    tmr_dmin		; DECREMENTAR DECENAS DE MINUTO
    DEC_UF_TEST 0xFF, 9, tmr_dmin, END_DEC  ; REVISION DE UNDERFLOW PARA CUENTA DE DECENAS DE MINUTO
    SET_DISPLAY tmr_useg, tmr_dseg, tmr_umin, tmr_dmin	; ACTUALIZAR DISPLAY
    END_DEC:
    RETURN
    
ALARM_OFF:			; SUBRUTINA PARA APAGADO MANUAL DE ALARMA
    BCF	    alarma, 0		; LIMPIAR BANDERA DE ALARMA
    BCF	    PORTA, 5		; APAGAR ALARMA FISICA
    RETURN
    
MODO_HORA:			; ESTADO DE HORA
    BTFSC   estado, 2		; 
    BCF	    estado, 2		;
    BSF	    estado, 0		;
    BTFSC   PORTA, 4		;
    BCF	    PORTA, 4		;
    BSF	    PORTA, 2		;
    RETURN
    
MODO_FECHA:			;
    BTFSC   estado, 0		;
    BCF	    estado, 0		;
    BSF	    estado, 1		;
    BTFSC   PORTA, 2		;
    BCF	    PORTA, 2		;
    BSF	    PORTA, 3		;
    RETURN
    
MODO_TIMER:			;
    BTFSC   estado, 1		;
    BCF	    estado, 1		;
    BSF	    estado, 2		;
    BTFSC   PORTA, 3		;
    BCF	    PORTA, 3		;
    BSF	    PORTA, 4		;
    CLRF    PORTE		;
    RETURN
    
//------------------------------MULTIPLEXADO------------------------------------   
SHOW_DISPLAY:
    BCF	    PORTD, 0		; LIMPIAR PIN0 DE PORTD
    BCF	    PORTD, 1		; LIMPIAR PIN1 DE PORTD
    BCF	    PORTD, 2		; LIMPIAR PIN1 DE PORTD
    BCF	    PORTD, 3		; LIMPIAR PIN1 DE PORTD
    MOVF    bandera, W		; REVISAR VALOR DE LA BANDERA PARA MULTIPLEXADO
    SUBLW   1			; USO DE RESTA PARA DETERMINAR SI ESTA EN ESTADO 1 
    BTFSC   ZERO		; REVISION DE ESTADO
    GOTO    DISPLAY_1		; SI LA BANDERA ESTA EN 1 INICIAR RDISPLAY_1
    MOVF    bandera, W		; REVISAR VALOR DE LA BANDERA PARA MULTIPLEXADO
    SUBLW   2			; USO DE RESTA PARA DETERMINAR SI ESTA EN ESTADO 2
    BTFSC   ZERO		; REVISION DE ESTADO
    GOTO    DISPLAY_2		; SI LA BANDERA ESTA EN 2 INICIAR LDISPLAY_2
    MOVF    bandera, W		; REVISAR VALOR DE LA BANDERA PARA MULTIPLEXADO	
    SUBLW   3			; USO DE RESTA PARA DETERMINAR SI ESTA EN ESTADO 2
    BTFSC   ZERO		; REVISION DE ESTADO
    GOTO    DISPLAY_3		; SI LA BANDERA ESTA EN 3 INICIAR LDISPLAY_3
    
    DISPLAY_0:			; SI LA BANDERA ESTABA EN 0 INICIAR DISPLAY_0
	MOVF    R_display, W	; MOVER VALOR DE DISPLAY_0 A REGISTRO W
	MOVWF   PORTC		; CARGAR VALOR AL PORTC PARA MOSTRAR EN DISPLAY
	BSF	PORTD, 0	; ACTIVAR PIN1 DE PORTD PARA ACTIVAR DISPLAY_0
	MOVLW	0x01		; SETEAR LA BADNERA A 1 PARA SIGUIENTE DISPLAY
	MOVWF	bandera		; CARGAR VALOR DE LA BANDERA
    RETURN
	
    DISPLAY_1:
	MOVF    R_display+1, W	; MOVER VALOR DE DISPLAY_1 A REGISTRO W
	MOVWF   PORTC		; CARGAR VALOR AL PORTC PARA MOSTRAR EN DISPLAY
	BSF	PORTD, 1	; ACTIVAR PIN0 DE PORTD PARA ACTIVAR DISPLAY_1
	MOVLW	0x02		; SETEAR LA BADNERA A 2 PARA SIGUIENTE DISPLAY
	MOVWF	bandera		; CARGAR VALOR DE LA BANDERA
    RETURN
	
    DISPLAY_2:
	MOVF    L_display, W	; MOVER VALOR DE DISPLAY_1 A REGISTRO W
	MOVWF   PORTC		; CARGAR VALOR AL PORTC PARA MOSTRAR EN DISPLAY
	BSF	PORTD, 2	; ACTIVAR PIN0 DE PORTD PARA ACTIVAR DISPLAY_1
	MOVLW	0x031		; SETEAR LA BADNERA A 3 PARA SIGUIENTE DISPLAY
	MOVWF	bandera		; CARGAR VALOR DE LA BANDERA
    RETURN
	
    DISPLAY_3:
	MOVF    L_display+1, W	; MOVER VALOR DE DISPLAY_1 A REGISTRO W
	MOVWF   PORTC		; CARGAR VALOR AL PORTC PARA MOSTRAR EN DISPLAY
	BSF	PORTD, 3	; ACTIVAR PIN0 DE PORTD PARA ACTIVAR DISPLAY_1
	MOVLW	0x0		; SETEAR LA BADNERA A 3 PARA SIGUIENTE DISPLAY
	MOVWF	bandera		; CARGAR VALOR DE LA BANDERA
    RETURN
END    